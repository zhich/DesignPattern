## 目录
- [6大设计原则](#6大设计原则)
  - [单一职责原则](#单一职责原则)
  - [里氏替换原则](#里氏替换原则)
  - [依赖倒置原则](#依赖倒置原则)
  - [接口隔离原则](#接口隔离原则)
  - [迪米特法则](#迪米特法则)
  - [开闭原则](#开闭原则)
- [23种设计模式](#23种设计模式)
  - [单例模式](#单例模式)
  - [工厂方法模式](#工厂方法模式)
  - [抽象工厂模式](#抽象工厂模式)
  - [模板方法模式](#模板方法模式)
  - [建造者模式](#建造者模式)
  - [代理模式](#代理模式)
  - [原型模式](#原型模式)
  - [中介者模式](#中介者模式)
  - [命令模式](#命令模式)
  - [责任链模式](#责任链模式)
  - [装饰模式](#装饰模式)
  - [策略模式](#策略模式)
  - [适配器模式](#适配器模式)
  - [迭代器模式](#迭代器模式)
  - [组合模式](#组合模式)
  - [观察者模式](#观察者模式)
  - [门面模式](#门面模式)
  - [备忘录模式](#备忘录模式)
  - [访问者模式](#访问者模式)
  - [状态模式](#状态模式)
  - [解释器模式](#解释器模式)
  - [享元模式](#享元模式)
  - [桥梁模式](#桥梁模式)
- [设计模式PK](#设计模式pk)
  - [创建类模式大PK](#创建类模式大pk)
    - [工厂方法模式VS建造者模式](#工厂方法模式vs建造者模式)
    - [抽象工厂模式VS建造者模式](#抽象工厂模式vs建造者模式)
  - [结构类模式大PK](#结构类模式大pk)
    - [代理模式VS装饰模式](#代理模式vs装饰模式)
    - [装饰模式VS适配器模式](#装饰模式vs适配器模式)
  - [行为类模式大PK](#行为类模式大pk)
    - [命令模式VS策略模式](#命令模式vs策略模式)
    - [策略模式VS状态模式](#策略模式vs状态模式)
    - [观察者模式VS责任链模式](#观察者模式vs责任链模式)
  - [跨战区PK](#跨战区pk)
    - [策略模式VS桥梁模式](#策略模式vs桥梁模式)
    - [门面模式VS中介者模式](#门面模式vs中介者模式)
    - [包装模式群PK](#包装模式群pk)
- [设计模式混编](#设计模式混编)
  - [命令模式add责任链模式](#命令模式add责任链模式)
  - [工厂方法模式add策略模式](#工厂方法模式add策略模式)
  - [观察者模式add中介者模式](#观察者模式add中介者模式)
- [扩展篇](#扩展篇)
  - [MVC框架](#mvc框架)
  - [新模式](#新模式)
    - [规格模式](#规格模式)
    - [对象池模式](#对象池模式)
    - [雇工模式](#雇工模式)
    - [黑板模式](#黑板模式)
    - [空对象模式](#空对象模式)
- [23种设计模式彩图](#23种设计模式彩图)




## 6大设计原则
#### 单一职责原则
单一职责原则的英文名称是Single Responsibility Principle， 简称是**SRP**。什么是单一职责原则呢？ 单一职责原则的定义是： **应该有且仅有一个原因引起类的变更。**

 但是别忘记了我们是面向接口编程， 我们对外公布的是接口而不是实现类，所以我们一般需要的是**接口的单一职责**。 如果真要实现类的单一职责， 这个就需要用聚合或组合的方式耦合在一起， 这会引起类间耦合过重、 类的数量增加等问题， 人为地增加了设计的复杂性。

单一职责原则有什么好处？

- 类的复杂性降低， 实现什么职责都有清晰明确的定义；
- 可读性提高， 复杂性降低， 那当然可读性提高了；
- 可维护性提高， 可读性提高， 那当然更容易维护了；
- 变更引起的风险降低， 变更是必不可少的， 如果接口的单一职责做得好， 一个接口修改只对相应的实现类有影响， 对其他的接口无影响， 这对系统的扩展性、 维护性都有非常大的帮助。

> 单一职责原则提出了一个编写程序的标准， 用“职责”或“变化原因”来衡量接口或类设计得是否优良， 但是“职责”和“变化原因”都是不可度量的， 因项目而异， 因环境而异。

单一职责适用于接口、 类， 同时也适用于方法， 什么意思呢？ 一个方法尽可能做一件事情， 比如一个方法修改用户密码， 不要把这个方法放到“修改用户信息”方法中， 尽量避免方法的颗粒度变粗。

**最佳实践：**

类的单一职责确实受非常多因素的制约， 纯理论地来讲， 这个原则是非常优秀的， 但是现实有现实的难处， 你必须去考虑项目
工期、 成本、 人员技术水平、 硬件情况、 网络情况等。对于单一职责原则， 我的建议是**接口一定要做到单一职责， 类的设计尽量做到只有一个原因引起变化。**

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/单一职责原则.md)

#### 里氏替换原则
里氏替换原则（ LiskovSubstitution Principle， **LSP**） ， 什么是里氏替换原则呢？其中一种定义是：**所有引用基类的地方必须能透明地使用其子类的对象。 **

通俗点讲， 只要父类能出现的地方子类就可以出现， 而且替换为子类也不会产生任何错误或异常， 使用者可能根本就不需要知道是父类还是子类。 但是， 反过来就不行了， 有子类出现的地方， 父类未必就能适应。

里氏替换原则为良好的继承定义了一个规范， 一句简单的定义包含了4层含义。
[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/里氏替换原则.md)

- 子类必须完全实现父类的方法
- 子类可以有自己的个性
- 覆盖或实现父类的方法时输入参数可以被放大
- 覆写或实现父类的方法时输出结果可以被缩小

**最佳实践**

在项目中， 采用里氏替换原则时， 尽量避免子类的“个性”， 一旦子类有“个性”， 这个子类和父类之间的关系就很难调和了， 把子类当做父类使用， 子类的“个性”被抹杀——委屈了点； 把子类单独作为一个业务来使用， 则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/里氏替换原则.md)

#### 依赖倒置原则
依赖倒置原则（ Dependence Inversion Principle,**DIP**） 。

它包括三层含义：

- 高层模块不应该依赖低层模块， 两者都应该依赖其抽象
- 抽象不应该依赖细节
- 细节应该依赖抽象

依赖倒置原则在Java语言中的表现就是：

- 模块间的依赖通过抽象发生， 实现类之间不发生直接的依赖关系， 其依赖关系是通过接口或抽象类产生的
- 接口或抽象类不依赖于实现类
- 实现类依赖接口或抽象类

> 更加精简的定义就是“面向接口编程”——OOD（ Object-Oriented Design， 面向对象设计） 的精髓之一。

采用依赖倒置原则可以减少类间的耦合性， 提高系统的稳定性， 降低并行开发引起的风险， 提高代码的可读性和可维护性。

** 依赖的三种写法**

- 构造函数传递依赖对象
- Setter方法传递依赖对象
- 接口声明依赖对象

**最佳实践**

依赖倒置原则的本质就是通过抽象（ 接口或抽象类） 使各个类或模块的实现彼此独立，不互相影响， 实现模块间的松耦合， 我们怎么在项目中使用这个规则呢？ 只要遵循以下的几个规则就可以：

- 每个类尽量都有接口或抽象类， 或者抽象类和接口两者都具备这是依赖倒置的基本要求， 接口和抽象类都是属于抽象的， 有了抽象才可能依赖倒置。

- 变量的表面类型尽量是接口或者是抽象类

  很多书上说变量的类型一定要是接口或者是抽象类， 这个有点绝对化了， 比如一个工具类， xxxUtils一般是不需要接口或是抽象类的。 还有， 如果你要使用类的clone方法， 就必须使用实现类， 这个是JDK提供的一个规范。
- 任何类都不应该从具体类派生

  如果一个项目处于开发状态， 确实不应该有从具体类派生出子类的情况， 但这也不是绝对的， 因为人都是会犯错误的， 有时设计缺陷是在所难免的， 因此只要不超过两层的继承都是可以忍受的。 特别是负责项目维护的同志， 基本上可以不考虑这个规则， 为什么？ 维护工作基本上都是进行扩展开发， 修复行为， 通过一个继承关系， 覆写一个方法就可以修正一个很大的Bug， 何必去继承最高的基类呢？ （ 当然这种情况尽量发生在不甚了解父类或者无法获得父类代码的情况下。）

- 尽量不要覆写基类的方法

  如果基类是一个抽象类， 而且这个方法已经实现了， 子类尽量不要覆写。 类间依赖的是抽象， 覆写了抽象方法， 对依赖的稳定性会产生一定的影响。

- 结合里氏替换原则使用

  里氏替换原则讲， 父类出现的地方子类就能出现， 再结合这里， 我们可以得出这样一个通俗的规则： 接口负责定义public属性和方法， 并且声明与其他对象的依赖关系， 抽象类负责公共构造部分的实现， 实现类准确的实现业务逻辑， 同时在适当的时候对父类进行细化。

> 依赖倒置原则是6个设计原则中最难以实现的原则， 它是实现开闭原则的重要途径， 依赖倒置原则没有实现， 就别想实现对扩展开放， 对修改关闭。 在项目中， 大家只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核心。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/依赖倒置原则.md)

#### 接口隔离原则
#### 迪米特法则
#### 开闭原则

## 23种设计模式
#### 单例模式
#### 工厂方法模式
#### 抽象工厂模式
#### 模板方法模式
#### 建造者模式
#### 代理模式
#### 原型模式
#### 中介者模式
#### 命令模式
#### 责任链模式
#### 装饰模式
#### 策略模式
#### 适配器模式
#### 迭代器模式
#### 组合模式
#### 观察者模式
#### 门面模式
#### 备忘录模式
#### 访问者模式
#### 状态模式
#### 解释器模式
#### 享元模式
#### 桥梁模式

## 设计模式PK
#### 创建类模式大PK
##### 工厂方法模式VS建造者模式
##### 抽象工厂模式VS建造者模式

#### 结构类模式大PK
##### 代理模式VS装饰模式
##### 装饰模式VS适配器模式

#### 行为类模式大PK
##### 命令模式VS策略模式
##### 策略模式VS状态模式
##### 观察者模式VS责任链模式

#### 跨战区PK
##### 策略模式VS桥梁模式
##### 门面模式VS中介者模式
##### 包装模式群PK

## 设计模式混编
#### 命令模式add责任链模式
#### 工厂方法模式add策略模式
#### 观察者模式add中介者模式

## 扩展篇
#### MVC框架

#### 新模式
##### 规格模式
##### 对象池模式
##### 雇工模式
##### 黑板模式
##### 空对象模式