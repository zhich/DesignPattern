## 目录
- [6大设计原则](#6大设计原则)
  - [单一职责原则](#单一职责原则)
  - [里氏替换原则](#里氏替换原则)
  - [依赖倒置原则](#依赖倒置原则)
  - [接口隔离原则](#接口隔离原则)
  - [迪米特法则](#迪米特法则)
  - [开闭原则](#开闭原则)
- [23种设计模式](#23种设计模式)
  - [单例模式](#单例模式)
  - [工厂方法模式](#工厂方法模式)
  - [抽象工厂模式](#抽象工厂模式)
  - [模板方法模式](#模板方法模式)
  - [建造者模式](#建造者模式)
  - [代理模式](#代理模式)
  - [原型模式](#原型模式)
  - [中介者模式](#中介者模式)
  - [命令模式](#命令模式)
  - [责任链模式](#责任链模式)
  - [装饰模式](#装饰模式)
  - [策略模式](#策略模式)
  - [适配器模式](#适配器模式)
  - [迭代器模式](#迭代器模式)
  - [组合模式](#组合模式)
  - [观察者模式](#观察者模式)
  - [门面模式](#门面模式)
  - [备忘录模式](#备忘录模式)
  - [访问者模式](#访问者模式)
  - [状态模式](#状态模式)
  - [解释器模式](#解释器模式)
  - [享元模式](#享元模式)
  - [桥梁模式](#桥梁模式)
- [设计模式PK](#设计模式pk)
  - [创建类模式大PK](#创建类模式大pk)
    - [工厂方法模式VS建造者模式](#工厂方法模式vs建造者模式)
    - [抽象工厂模式VS建造者模式](#抽象工厂模式vs建造者模式)
  - [结构类模式大PK](#结构类模式大pk)
    - [代理模式VS装饰模式](#代理模式vs装饰模式)
    - [装饰模式VS适配器模式](#装饰模式vs适配器模式)
  - [行为类模式大PK](#行为类模式大pk)
    - [命令模式VS策略模式](#命令模式vs策略模式)
    - [策略模式VS状态模式](#策略模式vs状态模式)
    - [观察者模式VS责任链模式](#观察者模式vs责任链模式)
  - [跨战区PK](#跨战区pk)
    - [策略模式VS桥梁模式](#策略模式vs桥梁模式)
    - [门面模式VS中介者模式](#门面模式vs中介者模式)
    - [包装模式群PK](#包装模式群pk)
- [设计模式混编](#设计模式混编)
  - [命令模式add责任链模式](#命令模式add责任链模式)
  - [工厂方法模式add策略模式](#工厂方法模式add策略模式)
  - [观察者模式add中介者模式](#观察者模式add中介者模式)
- [扩展篇](#扩展篇)
  - [MVC框架](#mvc框架)
  - [新模式](#新模式)
    - [规格模式](#规格模式)
    - [对象池模式](#对象池模式)
    - [雇工模式](#雇工模式)
    - [黑板模式](#黑板模式)
    - [空对象模式](#空对象模式)
- [23种设计模式彩图](#23种设计模式彩图)




## 6大设计原则
#### 单一职责原则
单一职责原则的英文名称是Single Responsibility Principle， 简称是**SRP**。什么是单一职责原则呢？ 单一职责原则的定义是： **应该有且仅有一个原因引起类的变更。**

 但是别忘记了我们是面向接口编程， 我们对外公布的是接口而不是实现类，所以我们一般需要的是**接口的单一职责**。 如果真要实现类的单一职责， 这个就需要用聚合或组合的方式耦合在一起， 这会引起类间耦合过重、 类的数量增加等问题， 人为地增加了设计的复杂性。

单一职责原则有什么好处？

- 类的复杂性降低， 实现什么职责都有清晰明确的定义；
- 可读性提高， 复杂性降低， 那当然可读性提高了；
- 可维护性提高， 可读性提高， 那当然更容易维护了；
- 变更引起的风险降低， 变更是必不可少的， 如果接口的单一职责做得好， 一个接口修改只对相应的实现类有影响， 对其他的接口无影响， 这对系统的扩展性、 维护性都有非常大的帮助。

> 单一职责原则提出了一个编写程序的标准， 用“职责”或“变化原因”来衡量接口或类设计得是否优良， 但是“职责”和“变化原因”都是不可度量的， 因项目而异， 因环境而异。

单一职责适用于接口、 类， 同时也适用于方法， 什么意思呢？ 一个方法尽可能做一件事情， 比如一个方法修改用户密码， 不要把这个方法放到“修改用户信息”方法中， 尽量避免方法的颗粒度变粗。

**最佳实践：**

类的单一职责确实受非常多因素的制约， 纯理论地来讲， 这个原则是非常优秀的， 但是现实有现实的难处， 你必须去考虑项目
工期、 成本、 人员技术水平、 硬件情况、 网络情况等。对于单一职责原则， 我的建议是**接口一定要做到单一职责， 类的设计尽量做到只有一个原因引起变化。**

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/单一职责原则.md)

#### 里氏替换原则
里氏替换原则（ LiskovSubstitution Principle， **LSP**） ， 什么是里氏替换原则呢？其中一种定义是：**所有引用基类的地方必须能透明地使用其子类的对象。 **

通俗点讲， 只要父类能出现的地方子类就可以出现， 而且替换为子类也不会产生任何错误或异常， 使用者可能根本就不需要知道是父类还是子类。 但是， 反过来就不行了， 有子类出现的地方， 父类未必就能适应。

里氏替换原则为良好的继承定义了一个规范， 一句简单的定义包含了4层含义。
[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/里氏替换原则.md)

- 子类必须完全实现父类的方法
- 子类可以有自己的个性
- 覆盖或实现父类的方法时输入参数可以被放大
- 覆写或实现父类的方法时输出结果可以被缩小

**最佳实践**

在项目中， 采用里氏替换原则时， 尽量避免子类的“个性”， 一旦子类有“个性”， 这个子类和父类之间的关系就很难调和了， 把子类当做父类使用， 子类的“个性”被抹杀——委屈了点； 把子类单独作为一个业务来使用， 则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/里氏替换原则.md)

#### 依赖倒置原则
#### 接口隔离原则
#### 迪米特法则
#### 开闭原则

## 23种设计模式
#### 单例模式
#### 工厂方法模式
#### 抽象工厂模式
#### 模板方法模式
#### 建造者模式
#### 代理模式
#### 原型模式
#### 中介者模式
#### 命令模式
#### 责任链模式
#### 装饰模式
#### 策略模式
#### 适配器模式
#### 迭代器模式
#### 组合模式
#### 观察者模式
#### 门面模式
#### 备忘录模式
#### 访问者模式
#### 状态模式
#### 解释器模式
#### 享元模式
#### 桥梁模式

## 设计模式PK
#### 创建类模式大PK
##### 工厂方法模式VS建造者模式
##### 抽象工厂模式VS建造者模式

#### 结构类模式大PK
##### 代理模式VS装饰模式
##### 装饰模式VS适配器模式

#### 行为类模式大PK
##### 命令模式VS策略模式
##### 策略模式VS状态模式
##### 观察者模式VS责任链模式

#### 跨战区PK
##### 策略模式VS桥梁模式
##### 门面模式VS中介者模式
##### 包装模式群PK

## 设计模式混编
#### 命令模式add责任链模式
#### 工厂方法模式add策略模式
#### 观察者模式add中介者模式

## 扩展篇
#### MVC框架

#### 新模式
##### 规格模式
##### 对象池模式
##### 雇工模式
##### 黑板模式
##### 空对象模式