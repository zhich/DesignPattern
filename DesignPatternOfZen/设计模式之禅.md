## 目录
- [6大设计原则](#6大设计原则)
  - [单一职责原则](#单一职责原则)
  - [里氏替换原则](#里氏替换原则)
  - [依赖倒置原则](#依赖倒置原则)
  - [接口隔离原则](#接口隔离原则)
  - [迪米特法则](#迪米特法则)
  - [开闭原则](#开闭原则)
- [23种设计模式](#23种设计模式)
  - [单例模式](#单例模式)
  - [工厂方法模式](#工厂方法模式)
  - [抽象工厂模式](#抽象工厂模式)
  - [模板方法模式](#模板方法模式)
  - [建造者模式](#建造者模式)
  - [代理模式](#代理模式)
  - [原型模式](#原型模式)
  - [中介者模式](#中介者模式)
  - [命令模式](#命令模式)
  - [责任链模式](#责任链模式)
  - [装饰模式](#装饰模式)
  - [策略模式](#策略模式)
  - [适配器模式](#适配器模式)
  - [迭代器模式](#迭代器模式)
  - [组合模式](#组合模式)
  - [观察者模式](#观察者模式)
  - [门面模式](#门面模式)
  - [备忘录模式](#备忘录模式)
  - [访问者模式](#访问者模式)
  - [状态模式](#状态模式)
  - [解释器模式](#解释器模式)
  - [享元模式](#享元模式)
  - [桥梁模式](#桥梁模式)
- [设计模式PK](#设计模式pk)
  - [创建类模式大PK](#创建类模式大pk)
    - [工厂方法模式VS建造者模式](#工厂方法模式vs建造者模式)
    - [抽象工厂模式VS建造者模式](#抽象工厂模式vs建造者模式)
  - [结构类模式大PK](#结构类模式大pk)
    - [代理模式VS装饰模式](#代理模式vs装饰模式)
    - [装饰模式VS适配器模式](#装饰模式vs适配器模式)
  - [行为类模式大PK](#行为类模式大pk)
    - [命令模式VS策略模式](#命令模式vs策略模式)
    - [策略模式VS状态模式](#策略模式vs状态模式)
    - [观察者模式VS责任链模式](#观察者模式vs责任链模式)
  - [跨战区PK](#跨战区pk)
    - [策略模式VS桥梁模式](#策略模式vs桥梁模式)
    - [门面模式VS中介者模式](#门面模式vs中介者模式)
    - [包装模式群PK](#包装模式群pk)
- [设计模式混编](#设计模式混编)
  - [命令模式add责任链模式](#命令模式add责任链模式)
  - [工厂方法模式add策略模式](#工厂方法模式add策略模式)
  - [观察者模式add中介者模式](#观察者模式add中介者模式)
- [扩展篇](#扩展篇)
  - [MVC框架](#mvc框架)
  - [新模式](#新模式)
    - [规格模式](#规格模式)
    - [对象池模式](#对象池模式)
    - [雇工模式](#雇工模式)
    - [黑板模式](#黑板模式)
    - [空对象模式](#空对象模式)
- [23种设计模式彩图](#23种设计模式彩图)




## 6大设计原则
#### 单一职责原则
单一职责原则的英文名称是Single Responsibility Principle， 简称是**SRP**。什么是单一职责原则呢？ 单一职责原则的定义是： **应该有且仅有一个原因引起类的变更。**

 但是别忘记了我们是面向接口编程， 我们对外公布的是接口而不是实现类，所以我们一般需要的是**接口的单一职责**。 如果真要实现类的单一职责， 这个就需要用聚合或组合的方式耦合在一起， 这会引起类间耦合过重、 类的数量增加等问题， 人为地增加了设计的复杂性。

单一职责原则有什么好处？

- 类的复杂性降低， 实现什么职责都有清晰明确的定义；

- 可读性提高， 复杂性降低， 那当然可读性提高了；

- 可维护性提高， 可读性提高， 那当然更容易维护了；

- 变更引起的风险降低， 变更是必不可少的， 如果接口的单一职责做得好， 一个接口修改只对相应的实现类有影响， 对其他的接口无影响， 这对系统的扩展性、 维护性都有非常大的帮助。

> 单一职责原则提出了一个编写程序的标准， 用“职责”或“变化原因”来衡量接口或类设计得是否优良， 但是“职责”和“变化原因”都是不可度量的， 因项目而异， 因环境而异。

单一职责适用于接口、 类， 同时也适用于方法， 什么意思呢？ 一个方法尽可能做一件事情， 比如一个方法修改用户密码， 不要把这个方法放到“修改用户信息”方法中， 尽量避免方法的颗粒度变粗。

**最佳实践：**

类的单一职责确实受非常多因素的制约， 纯理论地来讲， 这个原则是非常优秀的， 但是现实有现实的难处， 你必须去考虑项目
工期、 成本、 人员技术水平、 硬件情况、 网络情况等。对于单一职责原则， 我的建议是**接口一定要做到单一职责， 类的设计尽量做到只有一个原因引起变化。**

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/单一职责原则.md)

#### 里氏替换原则
里氏替换原则（ LiskovSubstitution Principle， **LSP**） ， 什么是里氏替换原则呢？其中一种定义是：**所有引用基类的地方必须能透明地使用其子类的对象。**

通俗点讲， 只要父类能出现的地方子类就可以出现， 而且替换为子类也不会产生任何错误或异常， 使用者可能根本就不需要知道是父类还是子类。 但是， 反过来就不行了， 有子类出现的地方， 父类未必就能适应。

里氏替换原则为良好的继承定义了一个规范， 一句简单的定义包含了4层含义。
[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/里氏替换原则.md)

- 子类必须完全实现父类的方法

- 子类可以有自己的个性

- 覆盖或实现父类的方法时输入参数可以被放大

- 覆写或实现父类的方法时输出结果可以被缩小

**最佳实践**

在项目中， 采用里氏替换原则时， 尽量避免子类的“个性”， 一旦子类有“个性”， 这个子类和父类之间的关系就很难调和了， 把子类当做父类使用， 子类的“个性”被抹杀——委屈了点； 把子类单独作为一个业务来使用， 则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/里氏替换原则.md)

#### 依赖倒置原则
依赖倒置原则（ Dependence Inversion Principle,**DIP**） 。

它包括三层含义：

- 高层模块不应该依赖低层模块， 两者都应该依赖其抽象

- 抽象不应该依赖细节

- 细节应该依赖抽象

依赖倒置原则在Java语言中的表现就是：

- 模块间的依赖通过抽象发生， 实现类之间不发生直接的依赖关系， 其依赖关系是通过接口或抽象类产生的

- 接口或抽象类不依赖于实现类

- 实现类依赖接口或抽象类

> 更加精简的定义就是“面向接口编程”——OOD（ Object-Oriented Design， 面向对象设计） 的精髓之一。

采用依赖倒置原则可以减少类间的耦合性， 提高系统的稳定性， 降低并行开发引起的风险， 提高代码的可读性和可维护性。

**依赖的三种写法** [demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/依赖倒置原则.md)

- 构造函数传递依赖对象

- Setter方法传递依赖对象

- 接口声明依赖对象

**最佳实践**

依赖倒置原则的本质就是通过抽象（ 接口或抽象类） 使各个类或模块的实现彼此独立，不互相影响， 实现模块间的松耦合， 我们怎么在项目中使用这个规则呢？ 只要遵循以下的几个规则就可以：

- 每个类尽量都有接口或抽象类， 或者抽象类和接口两者都具备这是依赖倒置的基本要求， 接口和抽象类都是属于抽象的， 有了抽象才可能依赖倒置。

- 变量的表面类型尽量是接口或者是抽象类

  很多书上说变量的类型一定要是接口或者是抽象类， 这个有点绝对化了， 比如一个工具类， xxxUtils一般是不需要接口或是抽象类的。 还有， 如果你要使用类的clone方法， 就必须使用实现类， 这个是JDK提供的一个规范。
- 任何类都不应该从具体类派生

  如果一个项目处于开发状态， 确实不应该有从具体类派生出子类的情况， 但这也不是绝对的， 因为人都是会犯错误的， 有时设计缺陷是在所难免的， 因此只要不超过两层的继承都是可以忍受的。 特别是负责项目维护的同志， 基本上可以不考虑这个规则， 为什么？ 维护工作基本上都是进行扩展开发， 修复行为， 通过一个继承关系， 覆写一个方法就可以修正一个很大的Bug， 何必去继承最高的基类呢？ （ 当然这种情况尽量发生在不甚了解父类或者无法获得父类代码的情况下。）

- 尽量不要覆写基类的方法

  如果基类是一个抽象类， 而且这个方法已经实现了， 子类尽量不要覆写。 类间依赖的是抽象， 覆写了抽象方法， 对依赖的稳定性会产生一定的影响。

- 结合里氏替换原则使用

  里氏替换原则讲， 父类出现的地方子类就能出现， 再结合这里， 我们可以得出这样一个通俗的规则： 接口负责定义public属性和方法， 并且声明与其他对象的依赖关系， 抽象类负责公共构造部分的实现， 实现类准确的实现业务逻辑， 同时在适当的时候对父类进行细化。

> 依赖倒置原则是6个设计原则中最难以实现的原则， 它是实现开闭原则的重要途径， 依赖倒置原则没有实现， 就别想实现对扩展开放， 对修改关闭。 在项目中， 大家只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核心。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/依赖倒置原则.md)

#### 接口隔离原则

**两种定义**：

- 客户端不应该依赖它不需要的接口

- 类间的依赖关系应该建立在最小的接口上

通俗地说，就是**接口尽量细化， 同时接口中的方法尽量少**。

> 注意：接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。

**保证接口的纯洁性**

接口隔离原则是对接口进行规范约束， 其包含以下4层含义：

- 接口要尽量小

  这是接口隔离原则的核心定义，不出现臃肿的接口（ Fat Interface），但是“小”是有限度的，首先就是不能违反单一职责原则。

- 接口要高内聚

  什么是高内聚？ **高内聚就是提高接口、 类、 模块的处理能力， 减少对外的交互**。 比如你告诉下属“到奥巴马的办公室偷一个×××文件”， 然后听到下属用坚定的口吻回答你： “是， 保证完成任务！ ”一个月后， 你的下属还真的把×××文件放到你的办公桌上了， 这种不讲任何条件、 立刻完成任务的行为就是高内聚的表现。 具体到接口隔离原则就是， 要求在接口中尽量
少公布public方法， 接口是对外的承诺， 承诺越少对系统的开发越有利， 变更的风险也就越少， 同时也有利于降低成本。

- 定制服务

  一个系统或系统内的模块之间必然会有耦合， 有耦合就要有相互访问的接口（ 并不一定就是Java中定义的Interface， 也可能是一个类或单纯的数据交换） ， 我们设计时就需要为各个访问者（ 即客户端） 定制服务， 什么是定制服务？ **定制服务就是单独为一个个体提供优良的服务**。 我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。 采用定制服务就必然有一个要求： **只提供访问者需要的方法**（避免不遵守文档约定带来的风险）。

- 接口设计是有限度的

  接口的设计粒度越小， 系统越灵活， 这是不争的事实。 但是， 灵活的同时也带来了结构的复杂化， 开发难度增加， 可维护性降低， 这不是一个项目或产品所期望看到的， 所以接口设计一定要注意适度， 这个“度”如何来判断呢？ 根据经验和常识判断， 没有一个固化或可测量的标准。

**最佳实践**

接口隔离原则是对接口的定义， 同时也是对类的定义， 接口和类尽量使用原子接口或原子类来组装。 但是， 这个原子该怎么划分是设计模式中的一大难题， 在实践中可以根据以下几个规则来衡量：

- 一个接口只服务于一个子模块或业务逻辑;

- 通过业务逻辑压缩接口中的public方法， 接口时常去回顾， 尽量让接口达到“满身筋骨肉”， 而不是“肥嘟嘟”的一大堆方法;

- 已经被污染了的接口， 尽量去修改， 若变更的风险较大， 则采用适配器模式进行转化处理；

- 了解环境， 拒绝盲从。 每个项目或产品都有特定的环境因素， 别看到大师是这样做的你就照抄。 千万别， 环境不同， 接口拆分的标准就不同。 深入了解业务逻辑， 最好的接口设计就出自你的手中。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/接口隔离原则.md)

#### 迪米特法则
迪米特法则（ Law of Demeter， LoD） 也称为最少知识原则（ Least KnowledgePrinciple， LKP） ， 虽然名字不同， 但描述的是同一个规则： 一个对象应该对其他对象有最少的了解。 通俗地讲， **一个类应该对自己需要耦合或调用的类知道得最少**， 你（ 被耦合或调用的类） 的内部是如何复杂都和我没关系， 那是你的事情， 我就知道你提供的这么多public方法， 我就调用这么多， 其他的我一概不关心。

迪米特法则对类的低耦合提出了明确的要求， 其包含以下4层含义。[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/迪米特法则.md)

- 只和朋友交流

  迪米特法则还有一个英文解释是： Only talk to your immediate friends（ 只与直接的朋友通信。） 什么叫做直接的朋友呢？ 每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。下面我们将举例说明如何才能做到只与直接的朋友交流。

  朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。

- 朋友间也是有距离的

  一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此， 为了保持朋友类间的距离， 在设计时需要反复衡量： 是否还可以再减少public方法和属性， 是否可以修改为private、 package-private（ 包类型， 在类、 方法、 变量前不加访问权限， 则默认为包类型） 、 protected等访问权限， 是否可以加上final关键字等。

  迪米特法则要求类“羞涩”一点， 尽量不要对外公布太多的public方法和非静态的public变量， 尽量内敛， 多使用private、 package-private、 protected等访问权限。

- 是自己的就是自己的

  在实际应用中经常会出现这样一个方法： 放在本类中也可以， 放在其他类中也没有错，那怎么去衡量呢？ 你可以坚持这样一个原则： 如果一个方法放在本类中， 既不增加类间关系， 也对本类不产生负面影响， 那就放置在本类中。

- 谨慎使用Serializable

  在实际应用中， 这个问题是很少出现的， 即使出现也会立即被发现并得到解决。 是怎么回事呢？ 举个例子来说， 在一个项目中使用RMI（ Remote Method Invocation， 远程方法调用） 方式传递一个VO（ Value Object， 值对象） ， 这个对象就必须实现Serializable接口（ 仅仅是一个标志性接口， 不需要实现具体的方法） ， 也就是把需要网络传输的对象进行序列化， 否则就会出现NotSerializableException异常。 突然有一天， 客户端的VO修改了一个属性的访问权限， 从private变更为public， 访问权限扩大了， 如果服务器上没有做出相应的变更， 就会报序列化失败， 就这么简单。 但是这个问题的产生应该属于项目管理范畴， 一个类或接口在客户端已经变更了， 而服务器端却没有同步更新， 难道不是项目管理的失职吗？

**最佳实践**

迪米特法则的核心观念就是类间解耦， 弱耦合， 只有弱耦合了以后， 类的复用率才可以提高。 其要求的结果就是产生了大量的中转或跳转类， 导致系统的复杂性提高， 同时也为维护带来了难度。 读者在采用迪米特法则时需要反复权衡， 既做到让结构清晰， 又做到高内聚低耦合。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/迪米特法则.md)

#### 开闭原则
开闭原则（Open Closed Principle，**OCP**）是Java世界里最基础的设计原则， 它指导我们如何建立一个稳定的、 灵活的系统。

开闭原则的定义：

一个软件实体如类、 模块和函数应该**对扩展开放， 对修改关闭**。

其含义是说一个软件实体应该通过扩展来实现变化， 而不是通过修改已有的代码来实现变化。它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则，真正实现“拥抱变化”。

那什么又是软件实体呢？ 软件实体包括以下几个部分：

- 项目或软件产品中按照一定的逻辑规则划分的模块

- 抽象和类

- 方法

开闭原则是最基础的一个原则， 前五个原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法， 而开闭原则才是其精神领袖。

**开闭原则的重要性**

- 开闭原则对测试的影响

  当有变化提出时， 我们就需要考虑一下，原有的健壮代码是否可以不修改， 仅仅通过扩展实现变化呢？ 否则， 就需要把原有的测试过程回笼一遍， 需要进行单元测试、 功能测试、 集成测试甚至是验收测试， 现在虽然在大力提倡自动化测试工具， 但是仍然代替不了人工的测试工作。

- 开闭原则可以提高复用性

  在面向对象的设计中， 所有的逻辑都是从原子逻辑组合而来的， 而不是在一个类中独立实现一个业务逻辑。 只有这样代码才可以复用， 粒度越小， 被复用的可能性就越大。 那为什么要复用呢？ 减少代码量， 避免相同的逻辑分散在多个角落， 避免日后的维护人员为了修改一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码， 然后发出对开发人员“极度失望”的感慨。 那怎么才能提高复用率呢？ 缩小逻辑粒度， 直到一个逻辑不可再拆分为止。

- 开闭原则可以提高可维护性

  一款软件投产后， 维护人员的工作不仅仅是对数据进行维护， 还可能要对程序进行扩展， 维护人员最乐意做的事情就是扩展一个类， 而不是修改一个类， 甭管原有的代码写得多么优秀还是多么糟糕， 让维护人员读懂原有的代码， 然后再修改， 是一件很痛苦的事情， 不要让他在原有的代码海洋里游弋完毕后再修改， 那是对维护人员的一种折磨和摧残。

- 面向对象开发的要求

  万物皆对象， 我们需要把所有的事物都抽象成对象， 然后针对对象进行操作， 但是万物皆运动， 有运动就有变化， 有变化就要有策略去应对， 怎么快速应对呢？ 这就需要在设计之初考虑到所有可能变化的因素， 然后留下接口， 等待“可能”转变为“现实”。

**如何使用开闭原则**

- 抽象约束

  抽象是对一组事物的通用描述， 没有具体的实现， 也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。 因此， 通过接口或抽象类可以约束一组可能变化的行为， 并且能够实现对扩展开放， 其包含三层含义： 第一， 通过接口或抽象类约束扩展， 对扩展进行边界限定， 不允许出现在接口或抽象类中不存在的public方法； 第二， 参数类型、 引用对象尽量使用接口或者抽象类， 而不是实现类； 第三， 抽象层尽量保持稳定， 一旦确定即不允许修改。

- 元数据（ metadata） 控制模块行为

  尽量使用元数据来控制程序的行为， 减少重复开发。 什么是元数据？ 用来描述环境和数据的数据， 通俗地说就是配置参数， 参数可以从文件中获得， 也可以从数据库中获得。其中达到极致的例子就是控制反转（ Inversion of Control） 

- 制定项目章程

  在一个团队中， 建立项目章程是非常重要的， 因为章程中指定了所有人员都必须遵守的约定， 对项目来说， 约定优于配置。 相信大家都做过项目， 会发现一个项目会产生非常多的配置文件。项目内约束， 每个项目成员都必须遵守， 该方法需要一个团队有较高的自觉性， 需要一个较长时间的磨合， 一旦项目成员都熟悉这样的规则， 比通过接口或抽象类进行约束效率更高， 而且扩展性一点也没有减少。

- 封装变化

  对变化的封装包含两层含义： 第一， 将相同的变化封装到一个接口或抽象类中； 第二，将不同的变化封装到不同的接口或抽象类中， 不应该有两个不同的变化出现在同一个接口或抽象类中。 封装变化， 也就是受保护的变化（ protected variations） ， 找出预计有变化或不稳定的点， 我们为这些变化点创建稳定的接口， 准确地讲是封装可能发生的变化， 一旦预测到或“第六感”发觉有变化， 就可以进行封装， 23个设计模式都是从各个不同的角度对变化进行封装的。

**最佳实践**

软件设计最大的难题就是应对需求的变化， 但是纷繁复杂的需求变化又是不可预料的。我们要为不可预料的事情做好准备。
6个原则的首字母（ 里氏替换原则和迪米特法则的首字母重复， 只取一个） 联合起来就是**SOLID**（ solid， 稳定的） ， 其代表的含义也就是把这6个原则结合使用的好处： 建立稳定、 灵活、 健壮的设计， 而开闭原则又是重中之重， 是最基础的原则， 是其他5大原则的精神领袖。 

使用开闭原则时要注意以下几个问题：

- 开闭原则也只是一个原则

  开闭原则只是精神口号， 实现拥抱变化的方法非常多， 并不局限于这6大设计原则， 但是遵循这6大设计原则基本上可以应对大多数变化。 因此， 我们在项目中应尽量采用这6大原则， 适当时候可以进行扩充， 例如通过类文件替换的方式完全可以解决系统中的一些缺陷。前提条件是： 类必须做到高内聚、 低耦合， 否则类文件的替换会引起不可预料的故障。

- 项目规章非常重要

  如果你是一位项目经理或架构师， 应尽量让自己的项目成员稳定， 稳定后才能建立高效的团队文化， 章程是一个团队所有成员共同的知识结晶， 也是所有成员必须遵守的约定。 优秀的章程能带给项目带来非常多的好处， 如提高开发效率、 降低缺陷率、 提高团队士气、 提高技术成员水平， 等等。

- 预知变化

  在实践中过程中， 架构师或项目经理一旦发现有发生变化的可能， 或者变化曾经发生过， 则需要考虑现有的架构是否可以轻松地实现这一变化。 架构师设计一套系统不仅要符合现有的需求， 还要适应可能发生的变化， 这才是一个优良的架构。

开闭原则是一个终极目标， 任何人包括大师级人物都无法百分之百做到， 但朝这个方向努力， 可以非常显著地改善一个系统的架构， 真正做到“拥抱变化”。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/开闭原则.md)

## 23种设计模式
#### 单例模式
单例模式（ Singleton Pattern） 是一个比较简单的模式， 其定义为：**确保某一个类只有一个实例， 而且自行实例化并向整个系统提供这个实例**。

**单例模式的优点**

- 由于单例模式在内存中只有一个实例， 减少了内存开支， 特别是一个对象需要频繁地创建、 销毁时， 而且创建或销毁时性能又无法优化， 单例模式的优势就非常明显。

- 由于单例模式只生成一个实例， 所以减少了系统的性能开销， 当一个对象的产生需要比较多的资源时， 如读取配置、 产生其他依赖对象时， 则可以通过在应用启动时直接产生一个单例对象， 然后用永久驻留内存的方式来解决（ 在Java EE中采用单例模式时需要注意JVM垃圾回收机制） 。

- 单例模式可以避免对资源的多重占用， 例如一个写文件动作， 由于只有一个实例存在内存中， 避免对同一个资源文件的同时写操作。

- 单例模式可以在系统设置全局的访问点， 优化和共享资源访问， 例如可以设计一个单例类， 负责所有数据表的映射处理。

**单例模式的缺点**

- 单例模式一般没有接口， 扩展很困难， 若要扩展， 除了修改代码基本上没有第二种途径可以实现。 单例模式为什么不能增加接口呢？ 因为接口对单例模式是没有任何意义的， 它要求“自行实例化”， 并且提供单一实例、 接口或抽象类是不可能被实例化的。 当然， 在特殊情况下， 单例模式可以实现接口、 被继承等， 需要在系统开发中根据环境判断。

- 单例模式对测试是不利的。 在并行开发环境中， 如果单例模式没有完成， 是不能进行测试的， 没有接口也不能使用mock的方式虚拟一个对象。

- 单例模式与单一职责原则有冲突。 一个类应该只实现一个逻辑， 而不关心它是否是单例的， 是不是要单例取决于环境， 单例模式把“要单例”和业务逻辑融合在一个类中。

**单例模式的使用场景**

- 要求生成唯一序列号的环境；

- 在整个项目中需要一个共享访问点或共享数据， 例如一个Web页面上的计数器， 可以不用把每次刷新都记录到数据库中， 使用单例模式保持计数器的值， 并确保是线程安全的；

- 创建一个对象需要消耗的资源过多， 如要访问IO和数据库等资源；

- 需要定义大量的静态常量和静态方法（ 如工具类） 的环境， 可以采用单例模式（ 当然， 也可以直接声明为static的方式） 。

**单例模式的注意事项**

- 考虑线程同步问题

  在高并发情况下， 请注意单例模式的线程同步问题。[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/单例模式.md)

- 考虑对象的复制情况

  在Java中， 对象默认是不可以被复制的， 若实现了Cloneable接口， 并实现了clone方法， 则可以直接通过对象复制方式创建一个新对象， 对象复制是不用调用类的构造函数， 因此即使是私有的构造函数， 对象仍然可以被复制。 在一般情况下， 类复制的情况不需要考虑， 很少会出现一个单例类会主动要求被复制的情况， 解决该问题的最好方法就是单例类不要实现Cloneable接口。

**单例模式的扩展**

如果一个类可以产生多个对象， 对象的数量不受限制， 则是非常容易实现的， 直接使用new关键字就可以了， 如果只需要一个对象， 使用单例模式就可以了， 但是如果要求一个类只能产生两三个对象呢？

需要产生固定数量对象的模式就叫做**有上限的多例模式**， 它是单例模式的一种扩展， 采用有上限的多例模式， 我们可以在设计时决定在内存中有多少个实例， 方便系统进行扩展， 修正单例可能存在的性能问题， 提供系统的响应速度。 例如读取文件， 我们可以在系统启动时完成初始化工作， 在内存中启动固定数量的reader实例， 然后在需要读取文件时就可以快速响应。[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/单例模式.md)

**最佳实践**

单例模式是23个模式中比较简单的模式， 应用也非常广泛， 如在Spring中， 每个Bean默认就是单例的， 这样做的优点是Spring容器可以管理这些Bean的生命期， 决定什么时候创建出来， 什么时候销毁， 销毁的时候要如何处理， 等等。 如果采用非单例模式（ Prototype类型） ， 则Bean初始化后的管理交由J2EE容器， Spring容器不再跟踪管理Bean的生命周期。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/单例模式.md)

#### 工厂方法模式
工厂方法模式使用的频率非常高， 在我们日常的开发中总能见到它的身影。 其定义为：**定义一个用于创建对象的接口， 让子类决定实例化哪一个类。 工厂方法使一个类的实例化延迟到其子类。**

**工厂方法模式的优点**

- 首先， 良好的封装性， 代码结构清晰。 一个对象创建是有条件约束的， 如一个调用者需要一个具体的产品对象， 只要知道这个产品的类名（ 或约束字符串） 就可以了， 不用知道创建对象的艰辛过程， 降低模块间的耦合。

- 其次， 工厂方法模式的扩展性非常优秀。 在增加产品类的情况下， 只要适当地修改具体的工厂类或扩展一个工厂类， 就可以完成“拥抱变化”。 例如在我们的例子中， 需要增加一个棕色人种， 则只需要增加一个BrownHuman类， 工厂类不用任何修改就可完成系统扩展。

- 再次， 屏蔽产品类。 这一特点非常重要， 产品类的实现如何变化， 调用者都不需要关心， 它只需要关心产品的接口， 只要接口保持不变， 系统中的上层模块就不要发生变化。 因为产品类的实例化工作是由工厂类负责的， 一个产品对象具体由哪一个产品生成是由工厂类决定的。 在数据库开发中， 大家应该能够深刻体会到工厂方法模式的好处： 如果使用JDBC连接数据库， 数据库从MySQL切换到Oracle， 需要改动的地方就是切换一下驱动名称（ 前提条件是SQL语句是标准语句） ， 其他的都不需要修改， 这是工厂方法模式灵活性的一个直接案例。

- 最后， 工厂方法模式是典型的解耦框架。 高层模块值需要知道产品的抽象类， 其他的实现类都不用关心， 符合迪米特法则， 我不需要的就不要去交流； 也符合依赖倒置原则， 只依赖产品类的抽象； 当然也符合里氏替换原则， 使用产品子类替换产品父类， 没问题！

**工厂方法模式的使用场景**

- 首先， 工厂方法模式是new一个对象的替代品， 所以在所有需要生成对象的地方都可以使用， 但是需要慎重地考虑是否要增加一个工厂类进行管理， 增加代码的复杂度。

- 其次， 需要灵活的、 可扩展的框架时， 可以考虑采用工厂方法模式。 万物皆对象， 那万物也就皆产品类， 例如需要设计一个连接邮件服务器的框架， 有三种网络协议可供选择：POP3、 IMAP、 HTTP， 我们就可以把这三种连接方法作为产品类， 定义一个接口如IConnectMail， 然后定义对邮件的操作方法， 用不同的方法实现三个具体的产品类（ 也就是连接方式） 再定义一个工厂方法， 按照不同的传入条件， 选择不同的连接方式。 如此设计，可以做到完美的扩展， 如某些邮件服务器提供了WebService接口， 很好， 我们只要增加一个产品类就可以了。

- 再次， 工厂方法模式可以用在异构项目中， 例如通过WebService与一个非Java的项目交互， 虽然WebService号称是可以做到异构系统的同构化， 但是在实际的开发中， 还是会碰到很多问题， 如类型问题、 WSDL文件的支持问题， 等等。 从WSDL中产生的对象都认为是一个产品， 然后由一个具体的工厂类进行管理， 减少与外围系统的耦合。

- 最后， 可以使用在测试驱动开发的框架下。 例如， 测试一个类A， 就需要把与类A有关联关系的类B也同时产生出来， 我们可以使用工厂方法模式把类B虚拟出来， 避免类A与类B的耦合。 目前由于JMock和EasyMock的诞生， 该使用场景已经弱化了，读者可以在遇到此种情况时直接考虑使用JMock或EasyMock。

**工厂方法模式的扩展**

工厂方法模式有很多扩展， 而且与其他模式结合使用威力更大， 下面将介绍4种扩展。

- 缩小为简单工厂模式

  我们这样考虑一个问题： 一个模块仅需要一个工厂类， 没有必要把它产生出来， 使用静态的方法就可以了， 根据这一要求， 我们去掉了AbstractHumanFactory抽象类， 同时把createHuman方法设置为静态类型， 简化了类的创建过程， 变更的源码仅仅是HumanFactory和NvWa类。HumanFactory类仅有两个地方发生变化： 去掉继承抽象类， 并在createHuman前增加static
关键字； 工厂类发生变化， 也同时引起了调用者NvWa的变化。

  该模式是工厂方法模式的弱化， 因为简单， 所以称为简单工厂模式（ Simple Factory Pattern） ， 也叫做静态工厂模式。 在实际项目中， 采用该方法的案例还是比较多的， 其缺点是工厂类的扩展比较困难， 不符合开闭原则， 但它仍然是一个非常实用的设计模式。[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/工厂方法模式.md)

- 升级为多个工厂类

  当我们在做一个比较复杂的项目时， 经常会遇到初始化一个对象很耗费精力的情况， 所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。 例如， 一个产品类有5个具体实现， 每个实现类的初始化（ 不仅仅是new， 初始化包括new一个对象， 并对对象设置一定的初始值） 方法都不相同， 如果写在一个工厂方法中， 势必会导致该方法巨大无比，那该怎么办？

  考虑到需要结构清晰， 我们就为每个产品定义一个创造者， 然后由调用者自己去选择与哪个工厂方法关联。 我们还是以女娲造人为例， 每个人种都有一个固定的八卦炉， 分别造出黑色人种、 白色人种、 黄色人种。

  每一个产品类都对应了一个创建类， 好处就是创建类的职责清晰， 而且结构简单， 但是给可扩展性和可维护性带来了一定的影响。 为什么这么说呢？ 如果要扩展一个产品类， 就需要建立一个相应的工厂类， 这样就增加了扩展的难度。因为工厂类和产品类的数量相同， 维护时需要考虑两个对象之间的关系。

  当然， 在复杂的应用中一般采用多工厂的方法， 然后再增加一个**协调类**， 避免调用者与各个子工厂交流， 协调类的作用是封装子工厂类， 对高层模块提供统一的访问接口。[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/工厂方法模式.md)

- 替代单例模式

  单例模式的核心要求就是在内存中只有一个对象， 通过工厂方法模式也可以只在内存中生产一个对象。[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/工厂方法模式.md)

- 延迟初始化

  何为延迟初始化（ Lazy initialization） ？ 一个对象被消费完毕后， 并不立刻释放， 工厂类保持其初始状态， 等待再次被使用。[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/工厂方法模式.md)

**最佳实践**

工厂方法模式在项目中使用得非常频繁， 以至于很多代码中都包含工厂方法模式。 该模式几乎尽人皆知， 但不是每个人都能用得好。 熟能生巧， 熟练掌握该模式， 多思考工厂方法如何应用， 而且工厂方法模式还可以与其他模式混合使用（ 例如模板方法模式、 单例模式、原型模式等） ， 变化出无穷的优秀设计， 这也正是软件设计和开发的乐趣所在。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/工厂方法模式.md)

#### 抽象工厂模式
抽象工厂模式（Abstract Factory Pattern）是一种比较常用的模式，其定义如下：**为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。**

**抽象工厂模式的优点**

- 封装性

  每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。

- 产品族内的约束为非公开状态

  例如生产男女比例的问题上，猜想女娲娘娘肯定有自己的打算，不能让女盛男衰，否则女性的优点不就体现不出来了吗？那在抽象工厂模式，就应该有这样的一个约束：每生产1个女性，就同时生产出1.2个男性，这样的生产过程对调用工厂类的高层模块来说是透明的，它不需要知道这个约束，我就是要一个黄色女性产品就可以了，具体的产品族内的约束是在工厂内实现的。

**抽象工厂模式的缺点**

  抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？如果要增加一个产品C，也就是说产品家族由原来的2个增加到3个，看看我们的程序有多大改动吧！抽象类AbstractCreator要增加一个方法createProductC()，然后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。改变契约，所有与契约有关系的代码都要修改，那么这段代码叫什么？叫“有毒代码”，——只要与这段代码有关系，就可能产生侵害的危险！

**抽象工厂模式的使用场景**

抽象工厂模式的使用场景定义非常简单：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式。什么意思呢？例如一个文本编辑器和一个图片处理器，都是软件实体，但是 * nix下的文本编辑器和Windows下的文本编辑器虽然功能和界面都相同，但是代码实现是不同的，图片处理器也有类似情况。也就是具有了共同的约束条件：操作系统类型。于是我们可以使用抽象工厂模式，产生不同操作系统下的编辑器和图片处理器。

**抽象工厂模式的注意事项**

在抽象工厂模式的缺点中，我们提到抽象工厂模式的产品族扩展比较困难，但是一定要清楚，是产品族扩展困难，而不是产品等级。在该模式下，产品等级是非常容易扩展的，增加一个产品等级，只要增加一个工厂类负责新增加出来的产品生产任务即可。也就是说横向
扩展容易，纵向扩展困难。以人类为例子，产品等级中只有男、女两个性别，现实世界还有一种性别：双性人，既是男人也是女人（俗语就是阴阳人），那我们要扩展这个产品等级也是非常容易的，增加三个产品类，分别对应不同的肤色，然后再创建一个工厂类，专门负责不同肤色人的双性人的创建任务，完全通过扩展来实现需求的变更，从这一点上看，抽象工厂模式是符合开闭原则的。

**最佳实践**

抽象工厂模式是一个简单的模式，使用的场景非常多，大家在软件产品开发过程中，涉及不同操作系统的时候，都可以考虑使用抽象工厂模式，例如一个应用，需要在三个不同平台（Windows、Linux、Android（Google发布的智能终端操作系统））上运行，你会怎么设计？分别设计三套不同的应用？非也，通过抽象工厂模式屏蔽掉操作系统对应用的影响。三个不同操作系统上的软件功能、应用逻辑、UI都应该是非常类似的，唯一不同的是调用不同的工厂方法，由不同的产品类去处理与操作系统交互的信息。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/抽象工厂模式.md)

#### 模板方法模式
模板方法模式（Template Method Pattern）：**定义一个操作中的算法的框架， 而将一些步骤延迟到子类中。 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。**

模板方法模式确实非常简单，仅仅使用了 Java 的继承机制，但它是一个应用非常广泛的模式。其中，抽象模板的方法分为两类：

- 基本方法

  基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。

- 模板方法

  可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。

> 为了防止恶意的操作，一般模板方法都加上 final 关键字， 不允许被覆写。

[制造悍马demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/模板方法模式.md)

**模板方法模式的优点**

- 封装不变部分，扩展可变部分

  把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。在悍马模型例子中，是不是就非常容易扩展？例如增加一个 H3 型号的悍马模型，很容易呀，增加一个子类，实现父类的基本方法就可以了。

- 提取公共部分代码，便于维护

  我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码！

- 行为由父类控制，子类实现

  基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。

**模板方法模式的缺点**

按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。 但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。

**模板方法模式的使用场景**

- 多个子类有公有的方法，并且逻辑基本相同时。
- 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。
- 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（见“模板方法模式的扩展”）约束其行为。

**模板方法模式的扩展**

客户提出 H1 型号的悍马喇叭想让它响就响，H2 型号的喇叭不要有声音。
[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/模板方法模式.md)

#### 建造者模式
#### 代理模式
#### 原型模式
#### 中介者模式
#### 命令模式
#### 责任链模式
#### 装饰模式
#### 策略模式
#### 适配器模式
#### 迭代器模式
#### 组合模式
#### 观察者模式
#### 门面模式
#### 备忘录模式
#### 访问者模式
#### 状态模式
#### 解释器模式
#### 享元模式
#### 桥梁模式

## 设计模式PK
#### 创建类模式大PK
##### 工厂方法模式VS建造者模式
##### 抽象工厂模式VS建造者模式

#### 结构类模式大PK
##### 代理模式VS装饰模式
##### 装饰模式VS适配器模式

#### 行为类模式大PK
##### 命令模式VS策略模式
##### 策略模式VS状态模式
##### 观察者模式VS责任链模式

#### 跨战区PK
##### 策略模式VS桥梁模式
##### 门面模式VS中介者模式
##### 包装模式群PK

## 设计模式混编
#### 命令模式add责任链模式
#### 工厂方法模式add策略模式
#### 观察者模式add中介者模式

## 扩展篇
#### MVC框架

#### 新模式
##### 规格模式
##### 对象池模式
##### 雇工模式
##### 黑板模式
##### 空对象模式