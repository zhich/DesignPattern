## 目录
- [6大设计原则](#6大设计原则)
  - [单一职责原则](#单一职责原则)
  - [里氏替换原则](#里氏替换原则)
  - [依赖倒置原则](#依赖倒置原则)
  - [接口隔离原则](#接口隔离原则)
  - [迪米特法则](#迪米特法则)
  - [开闭原则](#开闭原则)
- [23种设计模式](#23种设计模式)
  - [单例模式](#单例模式)
  - [工厂方法模式](#工厂方法模式)
  - [抽象工厂模式](#抽象工厂模式)
  - [模板方法模式](#模板方法模式)
  - [建造者模式](#建造者模式)
  - [代理模式](#代理模式)
  - [原型模式](#原型模式)
  - [中介者模式](#中介者模式)
  - [命令模式](#命令模式)
  - [责任链模式](#责任链模式)
  - [装饰模式](#装饰模式)
  - [策略模式](#策略模式)
  - [适配器模式](#适配器模式)
  - [迭代器模式](#迭代器模式)
  - [组合模式](#组合模式)
  - [观察者模式](#观察者模式)
  - [门面模式](#门面模式)
  - [备忘录模式](#备忘录模式)
  - [访问者模式](#访问者模式)
  - [状态模式](#状态模式)
  - [解释器模式](#解释器模式)
  - [享元模式](#享元模式)
  - [桥梁模式](#桥梁模式)
- [设计模式PK](#设计模式pk)
  - [创建类模式大PK](#创建类模式大pk)
    - [工厂方法模式VS建造者模式](#工厂方法模式vs建造者模式)
    - [抽象工厂模式VS建造者模式](#抽象工厂模式vs建造者模式)
  - [结构类模式大PK](#结构类模式大pk)
    - [代理模式VS装饰模式](#代理模式vs装饰模式)
    - [装饰模式VS适配器模式](#装饰模式vs适配器模式)
  - [行为类模式大PK](#行为类模式大pk)
    - [命令模式VS策略模式](#命令模式vs策略模式)
    - [策略模式VS状态模式](#策略模式vs状态模式)
    - [观察者模式VS责任链模式](#观察者模式vs责任链模式)
  - [跨战区PK](#跨战区pk)
    - [策略模式VS桥梁模式](#策略模式vs桥梁模式)
    - [门面模式VS中介者模式](#门面模式vs中介者模式)
    - [包装模式群PK](#包装模式群pk)
- [设计模式混编](#设计模式混编)
  - [命令模式add责任链模式](#命令模式add责任链模式)
  - [工厂方法模式add策略模式](#工厂方法模式add策略模式)
  - [观察者模式add中介者模式](#观察者模式add中介者模式)
- [扩展篇](#扩展篇)
  - [MVC框架](#mvc框架)
  - [新模式](#新模式)
    - [规格模式](#规格模式)
    - [对象池模式](#对象池模式)
    - [雇工模式](#雇工模式)
    - [黑板模式](#黑板模式)
    - [空对象模式](#空对象模式)
- [23种设计模式彩图](#23种设计模式彩图)




## 6大设计原则
#### 单一职责原则
单一职责原则的英文名称是Single Responsibility Principle， 简称是**SRP**。什么是单一职责原则呢？ 单一职责原则的定义是： **应该有且仅有一个原因引起类的变更。**

 但是别忘记了我们是面向接口编程， 我们对外公布的是接口而不是实现类，所以我们一般需要的是**接口的单一职责**。 如果真要实现类的单一职责， 这个就需要用聚合或组合的方式耦合在一起， 这会引起类间耦合过重、 类的数量增加等问题， 人为地增加了设计的复杂性。

单一职责原则有什么好处？

- 类的复杂性降低， 实现什么职责都有清晰明确的定义；
- 可读性提高， 复杂性降低， 那当然可读性提高了；
- 可维护性提高， 可读性提高， 那当然更容易维护了；
- 变更引起的风险降低， 变更是必不可少的， 如果接口的单一职责做得好， 一个接口修改只对相应的实现类有影响， 对其他的接口无影响， 这对系统的扩展性、 维护性都有非常大的帮助。

> 单一职责原则提出了一个编写程序的标准， 用“职责”或“变化原因”来衡量接口或类设计得是否优良， 但是“职责”和“变化原因”都是不可度量的， 因项目而异， 因环境而异。

单一职责适用于接口、 类， 同时也适用于方法， 什么意思呢？ 一个方法尽可能做一件事情， 比如一个方法修改用户密码， 不要把这个方法放到“修改用户信息”方法中， 尽量避免方法的颗粒度变粗。

**最佳实践：**

类的单一职责确实受非常多因素的制约， 纯理论地来讲， 这个原则是非常优秀的， 但是现实有现实的难处， 你必须去考虑项目
工期、 成本、 人员技术水平、 硬件情况、 网络情况等。对于单一职责原则， 我的建议是**接口一定要做到单一职责， 类的设计尽量做到只有一个原因引起变化。**

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/单一职责原则.md)

#### 里氏替换原则
里氏替换原则（ LiskovSubstitution Principle， **LSP**） ， 什么是里氏替换原则呢？其中一种定义是：**所有引用基类的地方必须能透明地使用其子类的对象。**

通俗点讲， 只要父类能出现的地方子类就可以出现， 而且替换为子类也不会产生任何错误或异常， 使用者可能根本就不需要知道是父类还是子类。 但是， 反过来就不行了， 有子类出现的地方， 父类未必就能适应。

里氏替换原则为良好的继承定义了一个规范， 一句简单的定义包含了4层含义。
[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/里氏替换原则.md)

- 子类必须完全实现父类的方法
- 子类可以有自己的个性
- 覆盖或实现父类的方法时输入参数可以被放大
- 覆写或实现父类的方法时输出结果可以被缩小

**最佳实践**

在项目中， 采用里氏替换原则时， 尽量避免子类的“个性”， 一旦子类有“个性”， 这个子类和父类之间的关系就很难调和了， 把子类当做父类使用， 子类的“个性”被抹杀——委屈了点； 把子类单独作为一个业务来使用， 则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/里氏替换原则.md)

#### 依赖倒置原则
依赖倒置原则（ Dependence Inversion Principle,**DIP**） 。

它包括三层含义：

- 高层模块不应该依赖低层模块， 两者都应该依赖其抽象
- 抽象不应该依赖细节
- 细节应该依赖抽象

依赖倒置原则在Java语言中的表现就是：

- 模块间的依赖通过抽象发生， 实现类之间不发生直接的依赖关系， 其依赖关系是通过接口或抽象类产生的
- 接口或抽象类不依赖于实现类
- 实现类依赖接口或抽象类

> 更加精简的定义就是“面向接口编程”——OOD（ Object-Oriented Design， 面向对象设计） 的精髓之一。

采用依赖倒置原则可以减少类间的耦合性， 提高系统的稳定性， 降低并行开发引起的风险， 提高代码的可读性和可维护性。

**依赖的三种写法**

- 构造函数传递依赖对象
- Setter方法传递依赖对象
- 接口声明依赖对象

**最佳实践**

依赖倒置原则的本质就是通过抽象（ 接口或抽象类） 使各个类或模块的实现彼此独立，不互相影响， 实现模块间的松耦合， 我们怎么在项目中使用这个规则呢？ 只要遵循以下的几个规则就可以：

- 每个类尽量都有接口或抽象类， 或者抽象类和接口两者都具备这是依赖倒置的基本要求， 接口和抽象类都是属于抽象的， 有了抽象才可能依赖倒置。

- 变量的表面类型尽量是接口或者是抽象类

  很多书上说变量的类型一定要是接口或者是抽象类， 这个有点绝对化了， 比如一个工具类， xxxUtils一般是不需要接口或是抽象类的。 还有， 如果你要使用类的clone方法， 就必须使用实现类， 这个是JDK提供的一个规范。
- 任何类都不应该从具体类派生

  如果一个项目处于开发状态， 确实不应该有从具体类派生出子类的情况， 但这也不是绝对的， 因为人都是会犯错误的， 有时设计缺陷是在所难免的， 因此只要不超过两层的继承都是可以忍受的。 特别是负责项目维护的同志， 基本上可以不考虑这个规则， 为什么？ 维护工作基本上都是进行扩展开发， 修复行为， 通过一个继承关系， 覆写一个方法就可以修正一个很大的Bug， 何必去继承最高的基类呢？ （ 当然这种情况尽量发生在不甚了解父类或者无法获得父类代码的情况下。）

- 尽量不要覆写基类的方法

  如果基类是一个抽象类， 而且这个方法已经实现了， 子类尽量不要覆写。 类间依赖的是抽象， 覆写了抽象方法， 对依赖的稳定性会产生一定的影响。

- 结合里氏替换原则使用

  里氏替换原则讲， 父类出现的地方子类就能出现， 再结合这里， 我们可以得出这样一个通俗的规则： 接口负责定义public属性和方法， 并且声明与其他对象的依赖关系， 抽象类负责公共构造部分的实现， 实现类准确的实现业务逻辑， 同时在适当的时候对父类进行细化。

> 依赖倒置原则是6个设计原则中最难以实现的原则， 它是实现开闭原则的重要途径， 依赖倒置原则没有实现， 就别想实现对扩展开放， 对修改关闭。 在项目中， 大家只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核心。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/依赖倒置原则.md)

#### 接口隔离原则

**两种定义**：

- 客户端不应该依赖它不需要的接口
- 类间的依赖关系应该建立在最小的接口上

通俗地说，就是**接口尽量细化， 同时接口中的方法尽量少**。

> 注意：接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。

**保证接口的纯洁性**

接口隔离原则是对接口进行规范约束， 其包含以下4层含义：

- 接口要尽量小

  这是接口隔离原则的核心定义，不出现臃肿的接口（ Fat Interface），但是“小”是有限度的，首先就是不能违反单一职责原则。

- 接口要高内聚

  什么是高内聚？ **高内聚就是提高接口、 类、 模块的处理能力， 减少对外的交互**。 比如你告诉下属“到奥巴马的办公室偷一个×××文件”， 然后听到下属用坚定的口吻回答你： “是， 保证完成任务！ ”一个月后， 你的下属还真的把×××文件放到你的办公桌上了， 这种不讲任何条件、 立刻完成任务的行为就是高内聚的表现。 具体到接口隔离原则就是， 要求在接口中尽量
少公布public方法， 接口是对外的承诺， 承诺越少对系统的开发越有利， 变更的风险也就越少， 同时也有利于降低成本。

- 定制服务

  一个系统或系统内的模块之间必然会有耦合， 有耦合就要有相互访问的接口（ 并不一定就是Java中定义的Interface， 也可能是一个类或单纯的数据交换） ， 我们设计时就需要为各个访问者（ 即客户端） 定制服务， 什么是定制服务？ **定制服务就是单独为一个个体提供优良的服务**。 我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。 采用定制服务就必然有一个要求： **只提供访问者需要的方法**（避免不遵守文档约定带来的风险）。

- 接口设计是有限度的

  接口的设计粒度越小， 系统越灵活， 这是不争的事实。 但是， 灵活的同时也带来了结构的复杂化， 开发难度增加， 可维护性降低， 这不是一个项目或产品所期望看到的， 所以接口设计一定要注意适度， 这个“度”如何来判断呢？ 根据经验和常识判断， 没有一个固化或可测量的标准。

**最佳实践**

接口隔离原则是对接口的定义， 同时也是对类的定义， 接口和类尽量使用原子接口或原子类来组装。 但是， 这个原子该怎么划分是设计模式中的一大难题， 在实践中可以根据以下几个规则来衡量：

- 一个接口只服务于一个子模块或业务逻辑;
- 通过业务逻辑压缩接口中的public方法， 接口时常去回顾， 尽量让接口达到“满身筋骨肉”， 而不是“肥嘟嘟”的一大堆方法;
- 已经被污染了的接口， 尽量去修改， 若变更的风险较大， 则采用适配器模式进行转化处理；
- 了解环境， 拒绝盲从。 每个项目或产品都有特定的环境因素， 别看到大师是这样做的你就照抄。 千万别， 环境不同， 接口拆分的标准就不同。 深入了解业务逻辑， 最好的接口设计就出自你的手中。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/接口隔离原则.md)

#### 迪米特法则
迪米特法则（ Law of Demeter， LoD） 也称为最少知识原则（ Least KnowledgePrinciple， LKP） ， 虽然名字不同， 但描述的是同一个规则： 一个对象应该对其他对象有最少的了解。 通俗地讲， **一个类应该对自己需要耦合或调用的类知道得最少**， 你（ 被耦合或调用的类） 的内部是如何复杂都和我没关系， 那是你的事情， 我就知道你提供的这么多public方法， 我就调用这么多， 其他的我一概不关心。

迪米特法则对类的低耦合提出了明确的要求， 其包含以下4层含义。[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/迪米特法则.md)

- 只和朋友交流

  迪米特法则还有一个英文解释是： Only talk to your immediate friends（ 只与直接的朋友通信。） 什么叫做直接的朋友呢？ 每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。下面我们将举例说明如何才能做到只与直接的朋友交流。

  朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。

- 朋友间也是有距离的

  一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此， 为了保持朋友类间的距离， 在设计时需要反复衡量： 是否还可以再减少public方法和属性， 是否可以修改为private、 package-private（ 包类型， 在类、 方法、 变量前不加访问权限， 则默认为包类型） 、 protected等访问权限， 是否可以加上final关键字等。

  迪米特法则要求类“羞涩”一点， 尽量不要对外公布太多的public方法和非静态的public变量， 尽量内敛， 多使用private、 package-private、 protected等访问权限。

- 是自己的就是自己的

  在实际应用中经常会出现这样一个方法： 放在本类中也可以， 放在其他类中也没有错，那怎么去衡量呢？ 你可以坚持这样一个原则： 如果一个方法放在本类中， 既不增加类间关系， 也对本类不产生负面影响， 那就放置在本类中。

- 谨慎使用Serializable

  在实际应用中， 这个问题是很少出现的， 即使出现也会立即被发现并得到解决。 是怎么回事呢？ 举个例子来说， 在一个项目中使用RMI（ Remote Method Invocation， 远程方法调用） 方式传递一个VO（ Value Object， 值对象） ， 这个对象就必须实现Serializable接口（ 仅仅是一个标志性接口， 不需要实现具体的方法） ， 也就是把需要网络传输的对象进行序列化， 否则就会出现NotSerializableException异常。 突然有一天， 客户端的VO修改了一个属性的访问权限， 从private变更为public， 访问权限扩大了， 如果服务器上没有做出相应的变更， 就会报序列化失败， 就这么简单。 但是这个问题的产生应该属于项目管理范畴， 一个类或接口在客户端已经变更了， 而服务器端却没有同步更新， 难道不是项目管理的失职吗？

**最佳实践**

迪米特法则的核心观念就是类间解耦， 弱耦合， 只有弱耦合了以后， 类的复用率才可以提高。 其要求的结果就是产生了大量的中转或跳转类， 导致系统的复杂性提高， 同时也为维护带来了难度。 读者在采用迪米特法则时需要反复权衡， 既做到让结构清晰， 又做到高内聚低耦合。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/迪米特法则.md)

#### 开闭原则
开闭原则（Open Closed Principle，**OCP**）是Java世界里最基础的设计原则， 它指导我们如何建立一个稳定的、 灵活的系统。

开闭原则的定义：

一个软件实体如类、 模块和函数应该**对扩展开放， 对修改关闭**。

其含义是说一个软件实体应该通过扩展来实现变化， 而不是通过修改已有的代码来实现变化。它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则，真正实现“拥抱变化”。

那什么又是软件实体呢？ 软件实体包括以下几个部分：

- 项目或软件产品中按照一定的逻辑规则划分的模块
- 抽象和类
- 方法

开闭原则是最基础的一个原则， 前五个原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法， 而开闭原则才是其精神领袖。

**开闭原则的重要性**

- 开闭原则对测试的影响

  当有变化提出时， 我们就需要考虑一下，原有的健壮代码是否可以不修改， 仅仅通过扩展实现变化呢？ 否则， 就需要把原有的测试过程回笼一遍， 需要进行单元测试、 功能测试、 集成测试甚至是验收测试， 现在虽然在大力提倡自动化测试工具， 但是仍然代替不了人工的测试工作。

- 开闭原则可以提高复用性

  在面向对象的设计中， 所有的逻辑都是从原子逻辑组合而来的， 而不是在一个类中独立实现一个业务逻辑。 只有这样代码才可以复用， 粒度越小， 被复用的可能性就越大。 那为什么要复用呢？ 减少代码量， 避免相同的逻辑分散在多个角落， 避免日后的维护人员为了修改一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码， 然后发出对开发人员“极度失望”的感慨。 那怎么才能提高复用率呢？ 缩小逻辑粒度， 直到一个逻辑不可再拆分为止。

- 开闭原则可以提高可维护性

  一款软件投产后， 维护人员的工作不仅仅是对数据进行维护， 还可能要对程序进行扩展， 维护人员最乐意做的事情就是扩展一个类， 而不是修改一个类， 甭管原有的代码写得多么优秀还是多么糟糕， 让维护人员读懂原有的代码， 然后再修改， 是一件很痛苦的事情， 不要让他在原有的代码海洋里游弋完毕后再修改， 那是对维护人员的一种折磨和摧残。

- 面向对象开发的要求

  万物皆对象， 我们需要把所有的事物都抽象成对象， 然后针对对象进行操作， 但是万物皆运动， 有运动就有变化， 有变化就要有策略去应对， 怎么快速应对呢？ 这就需要在设计之初考虑到所有可能变化的因素， 然后留下接口， 等待“可能”转变为“现实”。

**如何使用开闭原则**

- 抽象约束

  抽象是对一组事物的通用描述， 没有具体的实现， 也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。 因此， 通过接口或抽象类可以约束一组可能变化的行为， 并且能够实现对扩展开放， 其包含三层含义： 第一， 通过接口或抽象类约束扩展， 对扩展进行边界限定， 不允许出现在接口或抽象类中不存在的public方法； 第二， 参数类型、 引用对象尽量使用接口或者抽象类， 而不是实现类； 第三， 抽象层尽量保持稳定， 一旦确定即不允许修改。

- 元数据（ metadata） 控制模块行为

  尽量使用元数据来控制程序的行为， 减少重复开发。 什么是元数据？ 用来描述环境和数据的数据， 通俗地说就是配置参数， 参数可以从文件中获得， 也可以从数据库中获得。其中达到极致的例子就是控制反转（ Inversion of Control） 

- 制定项目章程

  在一个团队中， 建立项目章程是非常重要的， 因为章程中指定了所有人员都必须遵守的约定， 对项目来说， 约定优于配置。 相信大家都做过项目， 会发现一个项目会产生非常多的配置文件。项目内约束， 每个项目成员都必须遵守， 该方法需要一个团队有较高的自觉性， 需要一个较长时间的磨合， 一旦项目成员都熟悉这样的规则， 比通过接口或抽象类进行约束效率更高， 而且扩展性一点也没有减少。

- 封装变化

  对变化的封装包含两层含义： 第一， 将相同的变化封装到一个接口或抽象类中； 第二，将不同的变化封装到不同的接口或抽象类中， 不应该有两个不同的变化出现在同一个接口或抽象类中。 封装变化， 也就是受保护的变化（ protected variations） ， 找出预计有变化或不稳定的点， 我们为这些变化点创建稳定的接口， 准确地讲是封装可能发生的变化， 一旦预测到或“第六感”发觉有变化， 就可以进行封装， 23个设计模式都是从各个不同的角度对变化进行封装的。

**最佳实践**

软件设计最大的难题就是应对需求的变化， 但是纷繁复杂的需求变化又是不可预料的。我们要为不可预料的事情做好准备。
6个原则的首字母（ 里氏替换原则和迪米特法则的首字母重复， 只取一个） 联合起来就是**SOLID**（ solid， 稳定的） ， 其代表的含义也就是把这6个原则结合使用的好处： 建立稳定、 灵活、 健壮的设计， 而开闭原则又是重中之重， 是最基础的原则， 是其他5大原则的精神领袖。 

使用开闭原则时要注意以下几个问题：

- 开闭原则也只是一个原则

  开闭原则只是精神口号， 实现拥抱变化的方法非常多， 并不局限于这6大设计原则， 但是遵循这6大设计原则基本上可以应对大多数变化。 因此， 我们在项目中应尽量采用这6大原则， 适当时候可以进行扩充， 例如通过类文件替换的方式完全可以解决系统中的一些缺陷。前提条件是： 类必须做到高内聚、 低耦合， 否则类文件的替换会引起不可预料的故障。

- 项目规章非常重要

  如果你是一位项目经理或架构师， 应尽量让自己的项目成员稳定， 稳定后才能建立高效的团队文化， 章程是一个团队所有成员共同的知识结晶， 也是所有成员必须遵守的约定。 优秀的章程能带给项目带来非常多的好处， 如提高开发效率、 降低缺陷率、 提高团队士气、 提高技术成员水平， 等等。

- 预知变化

  在实践中过程中， 架构师或项目经理一旦发现有发生变化的可能， 或者变化曾经发生过， 则需要考虑现有的架构是否可以轻松地实现这一变化。 架构师设计一套系统不仅要符合现有的需求， 还要适应可能发生的变化， 这才是一个优良的架构。

开闭原则是一个终极目标， 任何人包括大师级人物都无法百分之百做到， 但朝这个方向努力， 可以非常显著地改善一个系统的架构， 真正做到“拥抱变化”。

[demo](https://github.com/zhich/DesignPattern/blob/master/DesignPatternOfZen/demo/开闭原则.md)

## 23种设计模式
#### 单例模式
#### 工厂方法模式
#### 抽象工厂模式
#### 模板方法模式
#### 建造者模式
#### 代理模式
#### 原型模式
#### 中介者模式
#### 命令模式
#### 责任链模式
#### 装饰模式
#### 策略模式
#### 适配器模式
#### 迭代器模式
#### 组合模式
#### 观察者模式
#### 门面模式
#### 备忘录模式
#### 访问者模式
#### 状态模式
#### 解释器模式
#### 享元模式
#### 桥梁模式

## 设计模式PK
#### 创建类模式大PK
##### 工厂方法模式VS建造者模式
##### 抽象工厂模式VS建造者模式

#### 结构类模式大PK
##### 代理模式VS装饰模式
##### 装饰模式VS适配器模式

#### 行为类模式大PK
##### 命令模式VS策略模式
##### 策略模式VS状态模式
##### 观察者模式VS责任链模式

#### 跨战区PK
##### 策略模式VS桥梁模式
##### 门面模式VS中介者模式
##### 包装模式群PK

## 设计模式混编
#### 命令模式add责任链模式
#### 工厂方法模式add策略模式
#### 观察者模式add中介者模式

## 扩展篇
#### MVC框架

#### 新模式
##### 规格模式
##### 对象池模式
##### 雇工模式
##### 黑板模式
##### 空对象模式